[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AtlansApi.jl",
    "section": "",
    "text": "AtlansApi is a shell around the Atlantis subsidence model (Atlans.jl) to provide the capability to make projections of the expected settlement as a result of loading by running the consolidation module from Atlantis via API requests.\n\nAtlantis\nThe Atlantis subsidence model is developed and maintained by Deltares and can be used to create regional scale predictions of land subsidence based on 3D voxelmodels of the subsurface buildup in combination with management scenarios. Atlantis has the capability to calculate the expected settlement resulting from raising the land surface (i.e.¬†‚Äúloading‚Äù) with for example sand material, prior to construction phases of for instance building projects for residential areas. For more explanation of Atlantis, see the Background page or visit the Atlantis documentation.\n\n\nConnection to Digital Twin software\nThe capability of AtlansApi to run Atlantis via API requests makes it possible to directly incorporate settlement projections within Digital Twin software. A Digital Twin is a powerful tool that can be applied to a range of topics, such as housing development. In various sectors, a realistic representation of an object in relation to its context has proven to provide a faster and deeper understanding for stakeholders. Digital Twins can help to better and more quickly visualize subsurface conditions and their impact on related functions and developments.\nThis information enables stakeholders to be more aware of the implications of the subsurface and to use this knowledge in their planning and decision-making.\nFurthermore, Digital Twins can be part of a policy-informed knowledge platform. Such a platform can visualize future-oriented, interconnected developments and policy goals. It can serve as a collaborative environment for stakeholders to explore ‚Äúwhat if‚Äù scenarios, allowing for more coherent and well-informed decisions across sectors. The Digital Twin then evolves from being a mere representation of the physical world into a tool for collaboration, policy making, and shared problem-solving.\n\n\nUse of public subsurface data\nAtlansApi bases the settlement projections solely on subsurface data available from public databases such as the BRO Dutch national database."
  },
  {
    "objectID": "background/index.html",
    "href": "background/index.html",
    "title": "Background",
    "section": "",
    "text": "Atlantis modelling environment\nAtlantis is a tool that can be used to create regional and national scale predictions of soil subsidence based on 3D voxelmodels of the subsurface buildup and scenarios of for example phreatic groundwater level management. Normally in Atlantis, subsidence is calculated per 1D subsurface column as the sum of a combination of three processes:\n\nconsolidation\noxidation\nshrinkage\n\nIn general, Atlantis does not consider horizontal interaction between individual columns. In AtlansApi, the settlement is calculated only using the consolidation process; the oxidation and shrinkage processes are effectively ignored.\nBesides subsurface data input, the predictions of subsidence rely on an input groundwater table which is typically a long-term mean lowest groundwater table (MLGT; in Dutch: GLG). In the consolidation process, this groundwater table is used to determine the water- and exchange of pore-pressures. Normally, the groundwater table is also used to determine the parts of the columns where oxidation and shrinkage processes take place contribute to subsidence. For more details on the modelling concepts and specific equations, see the Atlantis documentation",
    "crumbs": [
      "Background"
    ]
  },
  {
    "objectID": "usage/data.html",
    "href": "usage/data.html",
    "title": "Input data",
    "section": "",
    "text": "The settlement calculations done by AtlansApi rely on two sources of input data: (1) a 3D voxelmodel, characterizing the geological and lithological buildup, and (2) a surface level grid for the present-day land elevation.\nIn the Netherlands, 3D voxelmodels are created by the TNO Geological Survey. Input voxelmodels must be in a standard x,y,z grid with and have standardized codes for the geological units and lithological classes which are used for parameterizing a run in Atlantis. AtlansApi uses GeoTOP (see explanation below) as the default voxelmodel input but it is possible to use a different (local) input model, as long as these contain the same standardized codes for geology and lithology.\n\nGeoTOP (3D voxelmodel)\nGeoTOP is a 3D voxelmodel which is part of the ‚ÄúBasisregistratie Ondergrond‚Äù (BRO), the Dutch key registry for subsurface data. GeoTOP depicts the 3D subsurface buildup in terms of stratigraphy and lithology in voxels of 100 x 100 x 0.5 meter, from the surface level up to a depth of -50 m NAP (Dutch Ordnance Datum). Based on statistical analyses, primaly using borehole data, each voxel is asigned the expected composition of the subsurface (e.g.¬†sand, gravel, clay or organic). The resolution of GeoTOP makes it suitable to use at a sub-regional scale, comparable to a 1:50.000 scale, which can support the planning phase of construction projects.\nCurrently, GeoTOP does not cover the entire Netherlands but complete national coverage is ongoing work. The image below shows the spatial coverage up untill 2023. Recently in 2024, the western part of Flevoland (around Almere) was also added to support housing developments in the area. Additional information on GeoTOP and full description of the methodology can be found here.\n\n\n\nSpatial coverage of the GeoTOP model.\n\n\n\n\nSurface level\nAlgemeen Hoogtebestand Nederland (AHN).",
    "crumbs": [
      "Usage",
      "Input data"
    ]
  },
  {
    "objectID": "usage/example.html",
    "href": "usage/example.html",
    "title": "Example API payload",
    "section": "",
    "text": "AtlansApi allows a user to submit polygons for the area(s) of interest where settlement calculations are done for specified loading thicknesses. Additionally, a desired groundwater level can be specified, which is a uniform groundwater level for the area of interest in meters +NAP. These can be submitted as a JSON object by sending a POST request with application/json. A user can submit one or more polygons and each polygon should contain the attributes ‚Äúid‚Äù and ‚Äúdikte‚Äù. The map below shows the locations of two example polygons near the city of Almere. Hovering your mouse over one the polygons shows that they contain both the required attributes and the resulting JSON structure for the POST request is shown below the map.\n\n\n\nAPI Endpoint and request body\nThe POST request should be submitted to the following endpoint:\nPOST /run\nand the POST body should have the following structure:\n{\n    \"gw\": -5,\n    \"geojson\": {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n            {\n                \"id\": \"0\",\n                \"type\": \"Feature\",\n                \"properties\": {\n                    \"id\": 1,\n                    \"dikte\": 1.5\n                },\n                \"geometry\": {\n                    \"type\": \"Polygon\",\n                    \"coordinates\": [\n                        [\n                            [137692, 487627],\n                            [137787, 487840],\n                            [138127, 487910],\n                            [138295, 487791],\n                            [138291, 487639],\n                            [138156, 487426],\n                            [137860, 487356],\n                            [137672, 487451],\n                            [137692, 487627]\n                        ]\n                    ]\n                }\n            },\n            {\n                \"id\": \"1\",\n                \"type\": \"Feature\",\n                \"properties\": {\n                    \"id\": 2,\n                    \"dikte\": 0.8\n                },\n                \"geometry\": {\n                    \"type\": \"Polygon\",\n                    \"coordinates\": [\n                        [\n                            [139087, 488123],\n                            [139411, 487984],\n                            [139403, 487762],\n                            [139251, 487697],\n                            [139042, 487849],\n                            [139087, 488123]\n                        ]\n                    ]\n                }\n            }\n        ],\n        \"crs\": {\n            \"type\": \"name\",\n            \"properties\": {\n                \"name\": \"urn:ogc:def:crs:EPSG::28992\"\n            }\n        }\n    }\n}\n\n\nField explanation\n\n\n\nField\nType\nDescription\n\n\n\n\ngw\nnumber\nGroundwater level for the area of interest, in m above/below NAP\n\n\ngeojson\nobject\nGeoJSON FeatureCollection\n\n\nproperties.id\ninteger\nUnique identifier for each area\n\n\nproperties.dikte\nnumber\nThickness (in m) for the area\n\n\ngeometry\nPolygon\nCoordinates that define the boundary of the area\n\n\ncrs\nobject\nCoordinate Reference System (in this case EPSG:28992 / RD)\n\n\n\nüîπNotes:\n\nAll coordinates must be in Rijksdriehoekstelsel (RD) coordinates (EPSG:28992).\nThe dikte can be defined individually for each polygon.\nThe id in properties is used for internal identification.\n\n\n\nResponse\nA succesful request responds with a JSON which contains a hash id of the user request and paths to tif output that contain the resulting subsidence, due to settlement, for two periods: ‚Äúinitial‚Äù and ‚Äúremaining‚Äù. Below is an example JSON response:\n{\n    \"id\":\"a1d6aeb4-f9b8-4b9f-be97-91c2e7d917e1\",\n    \"initial\":\"./docker/output/a1d6aeb4-f9b8-4b9f-be97-91c2e7d917e1/initial.tif\",\n    \"remaining\":\"./docker/output/a1d6aeb4-f9b8-4b9f-be97-91c2e7d917e1/remaining.tif\"\n}\n\n\nResponse status codes:\n\n\n\nCode\nMeaning\n\n\n\n\n200\nSuccess\n\n\n400\nBad request (for example, missing gw or geojson)",
    "crumbs": [
      "Usage",
      "Example API payload"
    ]
  },
  {
    "objectID": "build/index.html#index",
    "href": "build/index.html#index",
    "title": "API Reference",
    "section": "Index",
    "text": "Index\n\nAtlans.Model\nAtlansApi.GeoTop\nAtlansApi.GeoTop\nAtlansApi.add_antropogenic\nAtlansApi.create_surcharge\nAtlansApi.generate_unique_directory_id\nAtlansApi.prepare_voxelstack\nAtlansApi.rasterize_like\nAtlansApi.rasterize_like\nAtlansApi.rasterize_like\nAtlansApi.read_ahn\nAtlansApi.run\nAtlansApi.run_model\nAtlansApi.run_model\nAtlansApi.session\nAtlansApi.shift_down\nAtlansApi.shift_up\nAtlansApi.surcharge_netcdf\nBase.write"
  },
  {
    "objectID": "build/index.html#specific-function",
    "href": "build/index.html#specific-function",
    "title": "API Reference",
    "section": "Specific function",
    "text": "Specific function\n# AtlansApi.rasterize_like ‚Äî Function.\nrasterize_like(features::GeoJSON.FeatureCollection, geotop::GeoTop; kw...)\nRasterize the ‚Äúfids‚Äù of an incoming geojson with polygons within the 2D raster extent of the modelling area of GeoTop.\nrasterize_like(features::GeoJSON.FeatureCollection, geotop::GeoTop, field::Symbol)\nRasterize a field of an incoming geojson with polygons within the 2D raster extent of the modelling area of GeoTop."
  },
  {
    "objectID": "build/index.html#modules",
    "href": "build/index.html#modules",
    "title": "API Reference",
    "section": "Modules",
    "text": "Modules"
  },
  {
    "objectID": "build/index.html#types",
    "href": "build/index.html#types",
    "title": "API Reference",
    "section": "Types",
    "text": "Types\n# Atlans.Model ‚Äî Method.\nModel(geotop::GeoTop, ahn::Raster, thickness::Raster, gw::Number)\nCreate a model of Atlantis SoilColumns based on the provided geographical and geological data. SoilColumns are created for locations where surcharge thickness is available.\n# AtlansApi.GeoTop ‚Äî Method.\nGeoTop(url::AbstractString, bbox::BoundingBox)\nRead GeoTop data directly from the Opendap server for a selected area in a bounding box.\n# AtlansApi.GeoTop ‚Äî Method.\nGeoTop(geotop::Dataset, bbox::BoundingBox)\nSelect GeoTop data for a selected bounding box from a NCDatasets.Dataset."
  },
  {
    "objectID": "build/index.html#functions",
    "href": "build/index.html#functions",
    "title": "API Reference",
    "section": "Functions",
    "text": "Functions\n# AtlansApi.add_antropogenic ‚Äî Method.\nadd_antropogenic(\n    thickness::Vector{Number},\n    strat::Vector{Number},\n    litho::Vector{Number},\n    difference::Number\n)\nAdd a layer of antropogenic material to the voxelstack with the appropriate thickness.\n# AtlansApi.create_surcharge ‚Äî Method.\ncreate_surcharge(thickness::Raster)\nCreate an Atlantis Surcharge based on the Raster dataset with the surcharge thickness to apply. Returns an Atlans.Forcings object that contains the surcharge and which can be passed to an Atlantis model simulation.\n# AtlansApi.generate_unique_directory_id ‚Äî Method.\ngenerate_unique_directory_id()\nHelper function to generate a unique directory id-hash for different API calls to store model output tifs.\n# AtlansApi.prepare_voxelstack ‚Äî Method.\nprepare_voxelstack(\n    z::Vector{Number},\n    surface::Number,\n    strat::Vector{Number},\n    litho::Vector{Number}\n)\nCreate an Atlantis VerticalDomain from a voxelstack of GeoTOP. This checks the depths against the surface level elevation and corrects voxel thicknesses that are above or below the surface level. If the surface level elevation is more than 2 meters higher than the elevation of the highest voxel, a layer of antropogenic material is added with the appropriate thickness.\nArguments:\n\nz: NAP Depth of each voxel.\nsurface: Surface level elevation in NAP.\nstrat: Stratigraphic unit of each voxel.\nlitho: Lithology of each voxel.\n\n# AtlansApi.rasterize_like ‚Äî Method.\nrasterize_like(features::GeoJSON.FeatureCollection, geotop::GeoTop, field::Symbol)\nRasterize a field of an incoming geojson with polygons within the 2D raster extent of the modelling area of GeoTop.\n# AtlansApi.rasterize_like ‚Äî Method.\nrasterize_like(features::GeoJSON.FeatureCollection, geotop::GeoTop; kw...)\nRasterize the ‚Äúfids‚Äù of an incoming geojson with polygons within the 2D raster extent of the modelling area of GeoTop.\n# AtlansApi.read_ahn ‚Äî Method.\nread_ahn(path::AbstractString, bbox::BoundingBox)\nRead a 100x100 meter resolution tif of AHN data.\n# AtlansApi.run ‚Äî Method.\nrun(simulation::Atlans.Simulation)\nRun the Atlans.Simulation object and return the subsidence results for ‚Äúinitial‚Äù and ‚Äúremaining‚Äù periods.\n# AtlansApi.run_model ‚Äî Method.\nrun_model(features::Features, groundwater::Number)\nRun a model simulation using the provided features and groundwater level. This builds an Atlantis model directly from GeoTOP data and a local AHN raster. The simulation is run for a time period of 60 years, divided into the first 3 years (‚Äúinitial‚Äù) and the remaining 57 years (‚Äúremaining‚Äù) and returns a SurchargeResult object.\n# AtlansApi.run_model ‚Äî Method.\nrun_model(req::HTTP.Request)\nProcess an HTTP request to run an Atlantis model simulation for surcharge calculations based on the provided input data.\nRequest JSON Structure\n\ngw: A numerical value representing the groundwater level.\ngeojson: A GeoJSON object representing the geographical features.\n\nResponse JSON Structure\n\nid: A unique identifier for the generated directory.\ninitial: The file path to the initial TIFF file.\nremaining: The file path to the remaining TIFF file.\n\nErrors\n\nReturns a 400 HTTP response with an error message if the input is invalid.\n\n# AtlansApi.session ‚Äî Method.\nsession(host::String, port::Int)\nStart an HTTP server session to listen for incoming requests to run Atlantis model simulations.\n# AtlansApi.shift_down ‚Äî Method.\nshift_down(\n    thickness::Vector{Number},\n    strat::Vector{Number},\n    litho::Vector{Number},\n    surface::Number,\n    modelbase::Number\n)\nShift the top level of a voxelstack down to the surface level. This function reduces the thickness of the top voxel or adds the thickness of the top voxel to the voxel below if the thickness is less than 0.1 meters.\n# AtlansApi.shift_up ‚Äî Method.\nshift_up(\n    thickness::Vector{Number},\n    strat::Vector{Number},\n    litho::Vector{Number},\n    surface::Number,\n    modelbase::Number\n)\nShift the top level of a voxelstack up to the surface level. This function increases the thickness of the top voxel or adds a new voxel with the appropriate thickness.\n# AtlansApi.surcharge_netcdf ‚Äî Method.\nsurcharge_netcdf(thickness::Raster)\nCreate a temporary NetCDF Dataset for the surcharge to apply in Atlantis based on a Raster dataset of the surcharge thickness.\n# Base.write ‚Äî Method.\nwrite(\n    result::SurchargeResult,\n    path_initial::AbstractString,\n    path_remaining::AbstractString\n)\nWrite the initial and remaining surcharge results to tif files."
  },
  {
    "objectID": "usage/run_local.html",
    "href": "usage/run_local.html",
    "title": "Run AtlansApi locally",
    "section": "",
    "text": "AtlansApi can be tested on a local machine. Assuming you have the Julia programming language installed and the AtlansApi repository cloned locally, first instantiate the project (i.e.¬†installing dependencies) by:\njulia --project -e \"using Pkg; Pkg.instantiate()\"\nNow, AtlansApi can be tested by starting an instance of localhost server and using a local coding session or any API testing tool (e.g.¬†Postman). Below, demonstrates how to run AtlansApi in a local coding session.\nAtlansApi contains a script run_server.jl which can start a localhost server instance. Start the server by typing the following Powershell command from the repository folder:\njulia --project \"run_server.jl\"\nStarting server on http://127.0.0.1:8081\n[ Info: Listening on: 127.0.0.1:8081, thread id: 1\nNow that a server connection has been established and AtlansApi is ‚Äúlistening‚Äù for incoming requests, you can open a new terminal and start a Julia session. The code snippet below can be used as the request to test AtlansApi. This uses AtlansApi.SAMPLE_PAYLOAD which is the same payload as the example features from the previous page. Running the code\nusing AtlansApi\nusing HTTP\n\npayload = AtlansApi.SAMPLE_PAYLOAD\nurl = \"http://127.0.0.1:8081/run\"\nheaders = [\"Content-Type\" =&gt; \"application/json\"]\nHTTP.post(url, headers, payload)\nHTTP.Messages.Response:\n\"\"\"\nHTTP/1.1 200 OK\nTransfer-Encoding: chunked\n\n{\"id\":\"a1d6aeb4-f9b8-4b9f-be97-91c2e7d917e1\",\"initial\":\"./docker/output/a1d6aeb4-f9b8-4b9f-be97-91c2e7d917e1/initial.tif\",\"remaining\":\"./docker/output/a1d6aeb4-f9b8-4b9f-be97-91c2e7d917e1/remaining.tif\"}\"\"\"\nExample result of ‚Äúinitial.tif‚Äù and ‚Äúremaining.tif‚Äù",
    "crumbs": [
      "Usage",
      "Run AtlansApi locally"
    ]
  },
  {
    "objectID": "usage/index.html",
    "href": "usage/index.html",
    "title": "Usage",
    "section": "",
    "text": "The following sections explain steps to integrate AtlansApi into a DigiTwin-like platform, API endpoints, payload structure to run the Atlantis simulations and the response contents.\nAtlansApi is not a publicly hosted API and therefore it is only functional within a specific platform deployment, such as a self-hosted DigiTwin-like platform. The repository contains a Docker image which can build an isolated environment for AtlansApi and which sets up a HTTP server session (at a user-specified location) to ‚Äúlisten‚Äù for incoming requests to run the Atlantis simulations.\n\n# Some test code cell\nusing AtlansApi\n\nAtlansApi.GeoTop\n\nAtlansApi.GeoTop",
    "crumbs": [
      "Usage"
    ]
  },
  {
    "objectID": "src/index.html",
    "href": "src/index.html",
    "title": "API Reference",
    "section": "",
    "text": "This is the private internal documentation of the AtlansApi API.\n\n\n\n\n\n\n\nCurrentModule = AtlansApi\nrasterize_like\n\n\n\nModules = [AtlansApi]\nOrder   = [:module]\n\n\n\nModules = [AtlansApi]\nOrder   = [:type]\n\n\n\nModules = [AtlansApi]\nOrder   = [:function]"
  },
  {
    "objectID": "src/index.html#specific-function",
    "href": "src/index.html#specific-function",
    "title": "API Reference",
    "section": "",
    "text": "CurrentModule = AtlansApi\nrasterize_like"
  },
  {
    "objectID": "src/index.html#modules",
    "href": "src/index.html#modules",
    "title": "API Reference",
    "section": "",
    "text": "Modules = [AtlansApi]\nOrder   = [:module]"
  },
  {
    "objectID": "src/index.html#types",
    "href": "src/index.html#types",
    "title": "API Reference",
    "section": "",
    "text": "Modules = [AtlansApi]\nOrder   = [:type]"
  },
  {
    "objectID": "src/index.html#functions",
    "href": "src/index.html#functions",
    "title": "API Reference",
    "section": "",
    "text": "Modules = [AtlansApi]\nOrder   = [:function]"
  }
]